{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "e74f47e8-7742-303c-8eb5-89fdea5e6ebf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "0b398d96-09c1-3192-8d97-50df4812b3e1",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in a memory copy operation. The code uses a memory copy function with two pointers, and dataflow analysis indicates that the source and destination may refer to overlapping memory areas. This can result in unpredictable program behavior, data corruption, or crashes. There are no explicit checks or guards in the code to prevent this overlap, and the function used does not handle overlapping regions safely. Both the source and destination pointers are confirmed to be non-null at this point, so the main risk is the potential for memory overlap. Developers should ensure that the source and destination do not overlap, or use a function that safely handles overlapping memory regions.\n\n## In Context Remediation 1\nBefore performing the memory copy, add a check to ensure that the source and destination memory regions do not overlap. If overlap is possible, use a safe memory move function that handles overlapping regions correctly.\n\n```cpp\nif ((dst < src && (char*)dst + width > (char*)src) ||\n    (src < dst && (char*)src + width > (char*)dst)) {\n    // Regions overlap, use memmove instead\n    std::memmove(dst, src, width);\n} else {\n    std::memcpy(dst, src, width);\n}\n```\n\n\n## In Context Remediation 2\nReplace the memory copy function with a memory move function that is designed to handle overlapping memory regions safely.\n\n```cpp\nstd::memmove(dst, src, width);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6b1007e6-ad99-3774-aef8-9d6cf8524efc",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The code uses a memory copy function with two pointers, and dataflow analysis suggests that the source and destination may refer to overlapping memory areas. This can lead to unpredictable results or program crashes. Additionally, there is no evidence of a guard to prevent null pointers for the source, which further increases the risk. The destination is not likely to be null, but the source may be. The count argument is not directly tied to the destination's capacity, and there are no explicit checks to ensure safe copying. All these factors indicate a high likelihood of a real issue that could result in undefined behavior or security vulnerabilities.\n\n## In Context Remediation 1\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap before calling the memory copy function. You can add a runtime check to verify that the memory ranges are disjoint:\n\n```cpp\nif ((dst < src && (char*)dst + width > src) || (src < dst && (char*)src + width > dst)) {\n    // Handle overlap: use memmove or adjust logic\n} else {\n    std::memcpy(dst, src, width);\n}\n```\nThis check ensures that the memory regions do not overlap. If they do, you can handle the situation appropriately, such as by using a different function or adjusting the logic.\n\n## In Context Remediation 2\nIf overlapping memory regions are possible, use a memory move function that safely handles overlap, such as `std::memmove`:\n\n```cpp\nstd::memmove(dst, src, width);\n```\nThis function is designed to handle overlapping memory regions safely and avoids undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0f126364-59e8-35c3-9d13-d5e73ee0e629",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable randomness which can be exploited by an attacker to predict the outcome of the random number generator, leading to a potential security breach.\n\nNon-cryptographic random number generators are designed for statistical randomness, not unpredictability. They are often initialized with predictable seeds, such as the system time, making it easier for an attacker to guess the sequence of random numbers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nAssuming `hip::detail::shuffle(var, src_lane, width)` is the vulnerable function, a potential fix could be to replace the random number generator used in this function with a cryptographically secure one. Here is an example of how to use a cryptographically secure random number generator in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nint random_number = dis(gen);\n```\n\nIn this example, `std::random_device` is a non-deterministic random number generator, and `std::mt19937` is a Mersenne Twister pseudorandom generator of 32-bit numbers with a state size of 19937 bits.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "899ba95a-21a3-3185-96d2-4448194e8bfd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the null-terminating character. If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null byte, potentially leading to a buffer overflow or other undefined behavior.\n\nIn the provided code snippet `!strlen(next)`, the vulnerability arises if `next` is not a null-terminated string. This could lead to unexpected behavior or even a security vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string after it has been modified.\n\n## Source Code Fix Recommendation\n\n```cpp\nif (next != NULL && next[0] != '\\0') {\n    // Your code here\n}\n```\n\nIn this fixed code, we first check if `next` is not NULL and then check if the first character of `next` is not the null character. This ensures that `next` is a null-terminated string before we use it.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed to use it.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "ea63b3ea-eece-34b0-a6d1-8258dee582a8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "11606eca-3a92-3252-a34a-c74a1dca5215",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both generic pointers, and dataflow analysis indicates that they may refer to overlapping memory. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null, which could lead to a crash. The function used for copying does not handle overlapping memory regions safely, and the absence of explicit size or capacity checks further increases the risk. These factors make this a high-confidence, actionable issue.\n\n## In Context Remediation 1\nAdd a runtime check to ensure that the source and destination memory regions do not overlap before performing the memory copy. This can be done by comparing the addresses and the size of the regions:\n\n```cpp\nif ((dst < src && (char*)dst + size > src) || (src < dst && (char*)src + size > dst)) {\n    // Handle overlap error, e.g., log or use memmove instead\n} else {\n    std::memcpy(dst, src, size);\n}\n```\nThis ensures that the memory regions do not overlap, preventing undefined behavior.\n\n## In Context Remediation 2\nIf overlapping memory regions are possible or cannot be ruled out, use `std::memmove` instead of `std::memcpy`, as `memmove` is designed to handle overlapping regions safely:\n\n```cpp\nstd::memmove(dst, src, size);\n```\nThis change ensures correct behavior even if the source and destination overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "68e4a93e-e30b-35e4-a854-4e2a5d14ab94",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause undefined behavior with the standard memory copy function. There are no explicit checks or guards in the code to prevent this overlap, and the function does not use a safer alternative that handles overlapping memory regions. Both the source and destination are not null at the call site, so the main risk is the potential for overlapping memory, which is not handled by the current implementation.\n\n## In Context Remediation 1\nAdd a runtime check to ensure that the source and destination memory regions do not overlap before performing the memory copy. If overlap is possible, use a safe alternative or handle the overlap explicitly.\n\n```cpp\nif ((dst < src && (char*)dst + byte_cnt > src) ||\n    (src < dst && (char*)src + byte_cnt > dst)) {\n    // Handle overlap: use memmove or custom logic\n    std::memmove(dst, src, byte_cnt);\n} else {\n    std::memcpy(dst, src, byte_cnt);\n}\n```\nThis approach ensures that undefined behavior is avoided by using the appropriate function when overlap is detected.\n\n## In Context Remediation 2\nReplace the memory copy operation with a function that is safe for overlapping memory regions. The standard library function `std::memmove` is designed for this purpose and should be used when there is any possibility of overlap.\n\n```cpp\nstd::memmove(dst, src, byte_cnt);\n```\nThis change ensures that the operation is safe regardless of whether the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "de7309ff-9cae-3675-a544-d7148a2778bf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet `memcpy(&r, &v, sizeof(T))`, if the size of `T` is larger than the size of `r`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `memcpy_s`:\n\n```cpp\n#include <string.h>\n\nT r;\nT v;\nsize_t size = sizeof(T);\nif (size <= sizeof(r)) {\n    memcpy_s(&r, size, &v, size);\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0dedf26b-e218-3c3c-8de7-fb929355654f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet `memcpy(&r, &v, sizeof(T))`, if the size of `T` is larger than the size of `r`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `memcpy_s`:\n\n```cpp\n#include <string.h>\n\nT r;\nT v;\nsize_t size = sizeof(T);\nif (size <= sizeof(r)) {\n    memcpy_s(&r, size, &v, size);\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7f90cd1f-e016-36a8-9e96-d5a1b5de0fa5",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a program uses a function that can lead to a security risk. In C++, certain functions are considered unsafe due to their potential to cause buffer overflows, integer overflows, or other types of vulnerabilities. One such function is `atoi()`, which converts a string to an integer. This function does not perform any error checking, so if the string cannot be converted into an integer, it will return a zero or a negative value, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `atoi()` and instead use functions that perform error checking, such as `strtol()`. This function allows you to specify the base for the conversion and it sets `errno` to `ERANGE` if the number cannot be represented.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi(argv[1])` with the following code:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n#include <climits>\n\nchar *endptr;\nlong val = strtol(argv[1], &endptr, 10);\n\nif ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN)) || (errno != 0 && val == 0)) {\n    perror(\"strtol\");\n    exit(EXIT_FAILURE);\n}\n\nif (endptr == argv[1]) {\n    fprintf(stderr, \"No digits were found\\n\");\n    exit(EXIT_FAILURE);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n- climits\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6f2f39ec-2f63-3a43-9dec-0a1617b2dded",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a C++ program uses certain C library functions that are considered unsafe. These functions are unsafe because they do not perform bounds checking or other necessary validation, which can lead to buffer overflow attacks, format string vulnerabilities, or integer overflows.\n\nIn this specific case, the function `atoi()` is used, which converts a string to an integer. `atoi()` does not check for overflow or underflow, and it does not signal any error if the input string does not represent a valid integer.\n\n## Mitigation Advice\n\nAvoid using `atoi()`. Instead, use functions that perform error checking, such as `strtol()`, or use C++ style input/output, which can throw exceptions on error.\n\n## Source Code Fix Recommendation\n\nReplace `atoi(argv[2])` with the following code:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *endptr;\nlong val = strtol(argv[2], &endptr, 10);\n\nif (errno == ERANGE || *endptr != '\\0' || endptr == argv[2]) {\n    // Handle the error...\n}\n```\n\nIn this code, `strtol()` is used to convert the string to a long integer. It sets `errno` to `ERANGE` on overflow or underflow, and it sets `endptr` to point to any remaining characters after the number.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: for `strtol()`\n- `<cerrno>`: for `errno`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "e74f47e8-7742-303c-8eb5-89fdea5e6ebf",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/include/hip/detail/intrinsics.hpp"
                },
                "region": {
                  "startLine": 208,
                  "startColumn": 10,
                  "endLine": 208,
                  "endColumn": 18,
                  "charOffset": 6586,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "0b398d96-09c1-3192-8d97-50df4812b3e1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/include/hip/detail/api.hpp"
                },
                "region": {
                  "startLine": 146,
                  "startColumn": 21,
                  "endLine": 146,
                  "endColumn": 44,
                  "charOffset": 3812,
                  "charLength": 23,
                  "snippet": {
                    "text": "memcpy(dst, src, width)",
                    "rendered": {
                      "text": "memcpy(dst, src, width)",
                      "markdown": "`memcpy(dst, src, width)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/include/hip/detail/api.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3812,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  width)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6b1007e6-ad99-3774-aef8-9d6cf8524efc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/include/hip/detail/api.hpp"
                },
                "region": {
                  "startLine": 177,
                  "startColumn": 29,
                  "endLine": 177,
                  "endColumn": 52,
                  "charOffset": 4828,
                  "charLength": 23,
                  "snippet": {
                    "text": "memcpy(dst, src, width)",
                    "rendered": {
                      "text": "memcpy(dst, src, width)",
                      "markdown": "`memcpy(dst, src, width)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/include/hip/detail/api.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4828,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  width)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0f126364-59e8-35c3-9d13-d5e73ee0e629",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/hip/hip_api.h"
                },
                "region": {
                  "startLine": 132,
                  "startColumn": 24,
                  "endLine": 132,
                  "endColumn": 32,
                  "charOffset": 2832,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "899ba95a-21a3-3185-96d2-4448194e8bfd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/hip_bus_bandwidth/hip_bus_bandwidth.cpp"
                },
                "region": {
                  "startLine": 608,
                  "startColumn": 12,
                  "endLine": 608,
                  "endColumn": 24,
                  "charOffset": 21058,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(next)",
                    "rendered": {
                      "text": "strlen(next)",
                      "markdown": "`strlen(next)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "examples/hip_bus_bandwidth/hip_bus_bandwidth.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21058,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(next, <size of next>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "examples/hip_bus_bandwidth/hip_bus_bandwidth.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21058,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(next, <size of next>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ea63b3ea-eece-34b0-a6d1-8258dee582a8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/occupancy/occupancy.cpp"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 5,
                  "endLine": 71,
                  "endColumn": 11,
                  "charOffset": 2505,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "11606eca-3a92-3252-a34a-c74a1dca5215",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/include/hip/detail/api.hpp"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 51,
                  "endLine": 124,
                  "endColumn": 73,
                  "charOffset": 3237,
                  "charLength": 22,
                  "snippet": {
                    "text": "memcpy(dst, src, size)",
                    "rendered": {
                      "text": "memcpy(dst, src, size)",
                      "markdown": "`memcpy(dst, src, size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/include/hip/detail/api.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3237,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "68e4a93e-e30b-35e4-a854-4e2a5d14ab94",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/include/hip/detail/api.hpp"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 17,
                  "endLine": 105,
                  "endColumn": 43,
                  "charOffset": 2725,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(dst, src, byte_cnt)",
                    "rendered": {
                      "text": "memcpy(dst, src, byte_cnt)",
                      "markdown": "`memcpy(dst, src, byte_cnt)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/include/hip/detail/api.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2725,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  byte_cnt)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "de7309ff-9cae-3675-a544-d7148a2778bf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/include/hip/detail/helpers.hpp"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 29,
                  "endLine": 65,
                  "endColumn": 53,
                  "charOffset": 2299,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(&r, &v, sizeof(T)",
                    "rendered": {
                      "text": "memcpy(&r, &v, sizeof(T)",
                      "markdown": "`memcpy(&r, &v, sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/include/hip/detail/helpers.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2299,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&r, <size of &r>,  &v,  sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0dedf26b-e218-3c3c-8de7-fb929355654f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/include/hip/detail/helpers.hpp"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 33,
                  "endLine": 57,
                  "endColumn": 57,
                  "charOffset": 1940,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(&r, &v, sizeof(T)",
                    "rendered": {
                      "text": "memcpy(&r, &v, sizeof(T)",
                      "markdown": "`memcpy(&r, &v, sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/include/hip/detail/helpers.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1940,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&r, <size of &r>,  &v,  sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7f90cd1f-e016-36a8-9e96-d5a1b5de0fa5",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/hip_dispatch_enqueue_rate_mt/hipDispatchEnqueueRateMT.cpp"
                },
                "region": {
                  "startLine": 132,
                  "startColumn": 22,
                  "endLine": 132,
                  "endColumn": 26,
                  "charOffset": 4721,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6f2f39ec-2f63-3a43-9dec-0a1617b2dded",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/hip_dispatch_enqueue_rate_mt/hipDispatchEnqueueRateMT.cpp"
                },
                "region": {
                  "startLine": 133,
                  "startColumn": 26,
                  "endLine": 133,
                  "endColumn": 30,
                  "charOffset": 4762,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}